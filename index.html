<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Enhanced Multimodal Vision-Speech AI App</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        :root {
            --primary-gradient: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            --secondary-gradient: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            --accent-gradient: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            --success-gradient: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
            --warning-gradient: linear-gradient(135deg, #ff9a9e 0%, #fecfef 100%);
            --error-gradient: linear-gradient(135deg, #ff6b6b 0%, #ee5a52 100%);
            
            --bg-dark: #0a0a0a;
            --bg-card: rgba(255, 255, 255, 0.05);
            --bg-card-hover: rgba(255, 255, 255, 0.08);
            --text-primary: #ffffff;
            --text-secondary: #b0b0b0;
            --text-muted: #888888;
            --border-color: rgba(255, 255, 255, 0.1);
            --shadow-light: 0 8px 32px rgba(0, 0, 0, 0.3);
            --shadow-heavy: 0 20px 40px rgba(0, 0, 0, 0.5);
            
            --animation-bounce: cubic-bezier(0.68, -0.55, 0.265, 1.55);
            --animation-smooth: cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg-dark);
            background-image: 
                radial-gradient(circle at 20% 20%, rgba(102, 126, 234, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 80% 80%, rgba(240, 147, 251, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 50% 50%, rgba(79, 172, 254, 0.05) 0%, transparent 50%);
            color: var(--text-primary);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            overflow-x: hidden;
        }
        
        .app-header {
            text-align: center;
            margin-bottom: 40px;
            animation: fadeInUp 0.8s var(--animation-smooth);
        }
        
        .app-title {
            font-size: clamp(2rem, 4vw, 3.5rem);
            font-weight: 700;
            background: var(--primary-gradient);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 10px;
            letter-spacing: -0.02em;
        }
        
        .app-subtitle {
            font-size: 1.2rem;
            color: var(--text-secondary);
            font-weight: 400;
            opacity: 0.8;
        }
        
        .glass-card {
            background: var(--bg-card);
            backdrop-filter: blur(20px);
            border: 1px solid var(--border-color);
            border-radius: 20px;
            box-shadow: var(--shadow-light);
            transition: all 0.3s var(--animation-smooth);
            position: relative;
            overflow: hidden;
        }
        
        .glass-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
        }
        
        .glass-card:hover {
            background: var(--bg-card-hover);
            transform: translateY(-2px);
            box-shadow: var(--shadow-heavy);
        }
        
        .controls, .io-areas, .speech-controls {
            padding: 25px;
            display: flex;
            gap: 15px;
            align-items: center;
            margin: 0 auto 20px auto;
            width: 100%;
            max-width: 800px;
            animation: fadeInUp 0.8s var(--animation-smooth);
        }
        
        .controls {
            justify-content: center;
            flex-wrap: wrap;
        }
        
        .io-areas {
            flex-direction: column;
            align-items: stretch;
            width: 100%;
            max-width: 800px;

        }
        
        .input-group {
            margin-bottom: 20px;
        }
        
        .input-group:last-child {
            margin-bottom: 0;
        }
        
        label {
            display: block;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 8px;
            font-size: 0.95rem;
            letter-spacing: 0.01em;
        }
        
        textarea {
            width: 100%;
            padding: 16px 20px;
            border: 2px solid var(--border-color);
            border-radius: 12px;
            font-size: 14px;
            font-family: inherit;
            background: rgba(255, 255, 255, 0.03);
            color: var(--text-primary);
            transition: all 0.3s var(--animation-smooth);
            resize: vertical;
            min-height: 60px;
            backdrop-filter: blur(10px);
        }
        
        textarea:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
            background: rgba(255, 255, 255, 0.05);
        }
        
        textarea::placeholder {
            color: var(--text-muted);
        }
        
        .video-container {
            position: relative;
            margin: 0 auto 30px auto;
            width: 100%;
            max-width: 800px;
            animation: fadeInUp 0.8s var(--animation-smooth) 0.2s both;
        }
        
        #videoFeed {
            width: 100%;
            max-width: 640px;
            height: auto;
            aspect-ratio: 4/3;
            border-radius: 20px;
            box-shadow: var(--shadow-heavy);
            background: var(--bg-dark);
            transition: all 0.3s var(--animation-smooth);
            display: block;
            margin: 0 auto;
        }
        
        #videoFeed:hover {
            transform: scale(1.02);
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.6);
        }
        
        .btn {
            padding: 14px 28px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            border: none;
            border-radius: 12px;
            color: white;
            margin: 0 8px;
            transition: all 0.3s var(--animation-smooth);
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            font-family: inherit;
            position: relative;
            overflow: hidden;
        }
        
        .btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s;
        }
        
        .btn:hover::before {
            left: 100%;
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
        }
        
        .btn:active {
            transform: translateY(0);
        }
        
        .btn-primary {
            background: var(--primary-gradient);
        }
        
        .btn-success {
            background: var(--success-gradient);
        }
        
        .btn-danger {
            background: var(--error-gradient);
        }
        
        .btn-info {
            background: var(--accent-gradient);
        }
        
        .btn:disabled {
            background: linear-gradient(135deg, #6c757d, #5a6268);
            cursor: not-allowed;
            transform: none;
        }
        
        .btn:disabled:hover {
            transform: none;
            box-shadow: none;
        }
        
        .btn:disabled::before {
            display: none;
        }
        
        .pulse-animation {
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% { 
                box-shadow: 0 0 0 0 rgba(220, 53, 69, 0.7);
            }
            70% {
                box-shadow: 0 0 0 20px rgba(220, 53, 69, 0);
            }
            100% {
                box-shadow: 0 0 0 0 rgba(220, 53, 69, 0);
            }
        }
        
        .hidden {
            display: none !important;
        }
        
        .loading {
            text-align: center;
            padding: 40px;
            width: 100%;
            max-width: 800px;
            margin: 0 auto;
            animation: fadeInUp 0.8s var(--animation-smooth);
        }
        
        .loading-spinner {
            width: 60px;
            height: 60px;
            border: 4px solid rgba(255, 255, 255, 0.1);
            border-top: 4px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .loading p {
            font-size: 1.1rem;
            color: var(--text-secondary);
            margin-bottom: 10px;
        }
        
        .loading #loadingStatus {
            font-size: 0.9rem;
            color: var(--text-muted);
        }
        
        .error {
            color: #ff6b6b;
            font-weight: 600;
        }
        
        .status-indicator {
            padding: 15px 20px;
            border-radius: 12px;
            font-size: 14px;
            font-weight: 500;
            margin: 0 auto 20px auto;
            width: 100%;
            max-width: 800px;
            position: relative;
            overflow: hidden;
            animation: fadeInUp 0.8s var(--animation-smooth) 0.3s both;
        }
        
        .status-indicator::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 4px;
            background: currentColor;
        }
        
        .status-ready {
            background: rgba(17, 153, 142, 0.1);
            color: #38ef7d;
            border: 1px solid rgba(56, 239, 125, 0.2);
        }
        
        .status-loading {
            background: rgba(255, 193, 7, 0.1);
            color: #ffc107;
            border: 1px solid rgba(255, 193, 7, 0.2);
        }
        
        .status-error {
            background: rgba(220, 53, 69, 0.1);
            color: #ff6b6b;
            border: 1px solid rgba(255, 107, 107, 0.2);
        }
        
        .speech-status {
            font-size: 14px;
            color: var(--text-secondary);
            font-style: italic;
            margin-left: 10px;
        }
        
        .caption-area {
            padding: 25px;
            margin: 0 auto 20px auto;
            min-height: 120px;
            width: 100%;
            max-width: 800px;
            animation: fadeInUp 0.8s var(--animation-smooth) 0.4s both;
        }
        
        .caption-text {
            font-size: 16px;
            line-height: 1.6;
            margin: 0;
            color: var(--text-primary);
        }
        
        .caption-label {
            font-weight: 600;
            margin-bottom: 12px;
            color: var(--text-primary);
            font-size: 1.1rem;
        }
        
        .performance-info {
            padding: 15px 20px;
            border-radius: 12px;
            font-size: 13px;
            color: var(--text-muted);
            margin: 0 auto 20px auto;
            width: 100%;
            max-width: 800px;
            background: rgba(255, 255, 255, 0.02);
            border: 1px solid var(--border-color);
            animation: fadeInUp 0.8s var(--animation-smooth) 0.5s both;
        }
        
        .performance-metrics {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
        }
        
        .metric {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .metric-value {
            font-weight: 600;
            color: var(--text-secondary);
        }
        
        select {
            padding: 12px 16px;
            border-radius: 8px;
            border: 2px solid var(--border-color);
            background: rgba(255, 255, 255, 0.03);
            color: var(--text-primary);
            font-family: inherit;
            font-size: 14px;
            transition: all 0.3s var(--animation-smooth);
        }
        
        select:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }
        
        /* Responsive Design */
        @media (max-width: 768px) {
            body {
                padding: 15px;
            }
            
            .app-header {
                margin-bottom: 30px;
            }
            
            .app-title {
                font-size: clamp(1.8rem, 5vw, 2.5rem);
            }
            
            .app-subtitle {
                font-size: 1rem;
            }
            
            .controls, .io-areas, .speech-controls {
                width: 100%;
                max-width: 100%;
                padding: 20px;
                gap: 12px;
            }
            
            .controls {
                flex-direction: column;
                gap: 10px;
            }
            
            .btn {
                width: 100%;
                justify-content: center;
                padding: 16px 24px;
                font-size: 16px;
            }
            
            .performance-metrics {
                flex-direction: column;
                gap: 10px;
            }
            
            .io-areas {
                padding: 20px;
            }
            
            .video-container {
                width: 100%;
                max-width: 100%;
                margin-bottom: 25px;
            }
            
            #videoFeed {
                max-width: 100%;
                border-radius: 15px;
            }
            
            .caption-area {
                width: 100%;
                max-width: 100%;
                padding: 20px;
                margin-bottom: 15px;
            }
            
            .status-indicator {
                width: 100%;
                max-width: 100%;
                padding: 12px 16px;
                margin-bottom: 15px;
            }
            
            .performance-info {
                width: 100%;
                max-width: 100%;
                padding: 12px 16px;
                margin-bottom: 15px;
            }
            
            .loading {
                width: 100%;
                max-width: 100%;
                padding: 30px 20px;
            }
            
            textarea {
                font-size: 16px; /* Prevents zoom on iOS */
                padding: 14px 16px;
                min-height: 80px;
            }
            
            .input-group {
                margin-bottom: 15px;
            }
            
            label {
                font-size: 0.9rem;
                margin-bottom: 6px;
            }
            
            .caption-text {
                font-size: 15px;
                line-height: 1.5;
            }
            
            .caption-label {
                font-size: 1rem;
                margin-bottom: 10px;
            }
        }
        
        @media (max-width: 480px) {
            body {
                padding: 10px;
            }
            
            .app-header {
                margin-bottom: 25px;
            }
            
            .app-title {
                font-size: clamp(1.5rem, 6vw, 2rem);
            }
            
            .app-subtitle {
                font-size: 0.9rem;
            }
            
            .controls, .io-areas, .speech-controls {
                padding: 15px;
                gap: 10px;
            }
            
            .btn {
                padding: 14px 20px;
                font-size: 15px;
            }
            
            .video-container {
                margin-bottom: 20px;
            }
            
            .caption-area {
                padding: 15px;
                margin-bottom: 12px;
            }
            
            .status-indicator {
                padding: 10px 14px;
                margin-bottom: 12px;
                font-size: 13px;
            }
            
            .performance-info {
                padding: 10px 14px;
                margin-bottom: 12px;
                font-size: 12px;
            }
            
            .loading {
                padding: 25px 15px;
            }
            
            textarea {
                padding: 12px 14px;
                min-height: 70px;
                font-size: 16px;
            }
            
            .input-group {
                margin-bottom: 12px;
            }
            
            label {
                font-size: 0.85rem;
                margin-bottom: 5px;
            }
            
            .caption-text {
                font-size: 14px;
            }
            
            .caption-label {
                font-size: 0.95rem;
                margin-bottom: 8px;
            }
            
            .performance-metrics {
                gap: 8px;
            }
            
            .metric {
                font-size: 12px;
            }
        }
        
        /* Animations */
        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        @keyframes fadeIn {
            from {
                opacity: 0;
            }
            to {
                opacity: 1;
            }
        }
        
        /* Scrollbar Styling */
        ::-webkit-scrollbar {
            width: 8px;
        }
        
        ::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
        }
        
        ::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            transition: background 0.3s ease;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.3);
        }
        
        /* Focus styles for accessibility */
        *:focus {
            outline: 2px solid #667eea;
            outline-offset: 2px;
        }
        
        button:focus,
        textarea:focus,
        select:focus {
            outline: none;
        }
        
        /* High contrast mode support */
        @media (prefers-contrast: high) {
            :root {
                --border-color: rgba(255, 255, 255, 0.3);
                --text-secondary: #cccccc;
            }
        }
        
        /* Reduced motion support */
        @media (prefers-reduced-motion: reduce) {
            * {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }
        
        /* Mobile-specific improvements */
        @media (max-width: 768px) {
            /* Prevent text selection on buttons for better mobile UX */
            .btn {
                -webkit-touch-callout: none;
                -webkit-user-select: none;
                -khtml-user-select: none;
                -moz-user-select: none;
                -ms-user-select: none;
                user-select: none;
                -webkit-tap-highlight-color: transparent;
            }
            
            /* Improve touch targets */
            .btn {
                min-height: 44px; /* iOS recommended minimum touch target */
                
            }
            
            /* Better scrolling on mobile */
            body {
                -webkit-overflow-scrolling: touch;
            }
            
            /* Prevent zoom on input focus */
            input, textarea, select {
                font-size: 16px;
            }
        }
        
        /* iOS Safari specific fixes */
        @supports (-webkit-touch-callout: none) {
            .glass-card {
                -webkit-transform: translateZ(0);
                transform: translateZ(0);
            }
            
            .btn {
                -webkit-appearance: none;
                appearance: none;
            }
        }
    </style>
</head>
<body>
    <div class="app-header">
        <h1 class="app-title">Vision AI Assistant</h1>
        <p class="app-subtitle">Intelligent multimodal interaction with speech and vision</p>
    </div>

    <div id="loadingDiv" class="glass-card loading">
        <div class="loading-spinner"></div>
        <p>Loading AI models...</p>
        <p id="loadingStatus">Initializing...</p>
    </div>

    <div id="modelStatus" class="status-indicator status-loading hidden">
        <span id="modelStatusText">Models not loaded</span>
    </div>

    <div id="performanceInfo" class="performance-info hidden">
        <div class="performance-metrics">
            <div class="metric">
                <span>Vision:</span>
                <span class="metric-value" id="visionTime">-</span>
                <span>ms</span>
            </div>
            <div class="metric">
                <span>Speech:</span>
                <span class="metric-value" id="speechTime">-</span>
                <span>ms</span>
            </div>
            <div class="metric">
                <span>FPS:</span>
                <span class="metric-value" id="fps">-</span>
            </div>
        </div>
    </div>

    <div class="video-container">
        <video id="videoFeed" autoplay playsinline muted class="hidden"></video>
        <canvas id="canvas" class="hidden"></canvas>
    </div>

    <div id="mainContent" class="hidden">
        <div class="glass-card caption-area">
            <div class="caption-label">🔍 What I see:</div>
            <p id="visionCaption" class="caption-text">Vision analysis will appear here...</p>
        </div>

        <div class="glass-card io-areas">
            <div class="input-group">
                <label for="instructionText">💬 Instruction (type or speak):</label>
                <textarea id="instructionText" name="Instruction" placeholder="Type your question or click the microphone to speak..."></textarea>
            </div>
            <div class="input-group">
                <label for="responseText">🤖 AI Response:</label>
                <textarea id="responseText" name="Response" readonly placeholder="AI response will appear here..."></textarea>
            </div>
        </div>

        <div class="glass-card controls">
            <button id="startButton" class="btn btn-success" disabled>
                🚀 Start AI Assistant
            </button>
            <span id="statusText" class="speech-status">Click to start real-time vision, speech, and response</span>
        </div>
    </div>

    <script type="module">
        import { pipeline, env } from 'https://cdn.jsdelivr.net/npm/@xenova/transformers@2.17.2';
        
        // Configure environment for better performance
        env.allowLocalModels = false;
        env.remoteURL = 'https://huggingface.co/';
        env.backends.onnx.wasm.numThreads = navigator.hardwareConcurrency || 4;
        
        // DOM element references
        const video = document.getElementById('videoFeed');
        const canvas = document.getElementById('canvas');
        const instructionText = document.getElementById('instructionText');
        const responseText = document.getElementById('responseText');
        const visionCaption = document.getElementById('visionCaption');
        const startButton = document.getElementById('startButton');
        const statusText = document.getElementById('statusText');
        const loadingDiv = document.getElementById('loadingDiv');
        const loadingStatus = document.getElementById('loadingStatus');
        const mainContent = document.getElementById('mainContent');
        const modelStatus = document.getElementById('modelStatus');
        const modelStatusText = document.getElementById('modelStatusText');
        const performanceInfo = document.getElementById('performanceInfo');
        const visionTimeSpan = document.getElementById('visionTime');
        const speechTimeSpan = document.getElementById('speechTime');
        const fpsSpan = document.getElementById('fps');

        // Global variables
        let stream;
        let recognition;
        let intervalId;
        let isAssistantActive = false;
        let visionProcessor = null;
        let speechProcessor = null;
        let ttsProcessor = null;
        let isModelReady = false;
        let lastProcessedSpeech = '';
        let lastProcessedVision = '';

        // Performance monitoring
        let frameCount = 0;
        let lastFrameTime = performance.now();
        let visionProcessingTime = 0;
        let speechProcessingTime = 0;
        let processingQueue = [];
        let isProcessing = false;

        // Image comparison for change detection
        let previousImageData = null;
        const CHANGE_THRESHOLD = 0.1; // 10% change threshold

        // Caching for repeated requests
        const responseCache = new Map();
        const CACHE_MAX_SIZE = 50;

        // Worker for background processing (if needed)
        let processingWorker = null;

        // Optimize canvas context
        let canvasContext = null;

        // Update model status display
        function updateModelStatus(status, message) {
            modelStatus.className = `status-indicator status-${status}`;
            modelStatusText.textContent = message;
            if (status === 'ready') {
                startButton.disabled = false;
                startButton.className = 'btn btn-primary';
                performanceInfo.classList.remove('hidden');
            }
        }

        // Initialize all AI models with optimizations
        async function initModels() {
            try {
                loadingStatus.textContent = 'Loading optimized vision model...';
                
                // Load smaller, faster vision model
                visionProcessor = await pipeline('image-to-text', 'Xenova/vit-gpt2-image-captioning', {
                    quantized: true, // Use quantized model for better performance
                    progress_callback: (progress) => {
                        if (progress.status === 'progress') {
                            const percent = Math.round(progress.progress);
                            loadingStatus.textContent = `Downloading vision model: ${percent}%`;
                        }
                    }
                });

                loadingStatus.textContent = 'Initializing speech recognition...';
                speechProcessor = null; // Use Web Speech API

                loadingStatus.textContent = 'Initializing speech synthesis...';
                ttsProcessor = null; // Use window.speechSynthesis
                
                isModelReady = true;
                loadingDiv.classList.add('hidden');
                mainContent.classList.remove('hidden');
                modelStatus.classList.remove('hidden');
                video.classList.remove('hidden');
                updateModelStatus('ready', 'All models loaded and ready');
                
                // Initialize camera with optimizations
                await initCamera();
                
            } catch (error) {
                console.error('Error loading models:', error);
                loadingStatus.textContent = `Error: ${error.message}`;
                loadingStatus.classList.add('error');
                updateModelStatus('error', `Failed to load models: ${error.message}`);
            }
        }

        // Initialize camera with optimizations
        async function initCamera() {
            try {
                // Detect mobile device and adjust constraints accordingly
                const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                
                // Request appropriate resolution for device type
                const constraints = {
                    video: {
                        width: { ideal: isMobile ? 480 : 640 },
                        height: { ideal: isMobile ? 360 : 480 },
                        frameRate: { ideal: isMobile ? 10 : 15, max: isMobile ? 20 : 30 },
                        facingMode: isMobile ? 'environment' : 'user' // Use back camera on mobile
                    },
                    audio: false
                };
                
                stream = await navigator.mediaDevices.getUserMedia(constraints);
                video.srcObject = stream;
                
                // Pre-initialize canvas context
                video.addEventListener('loadedmetadata', () => {
                    canvas.width = video.videoWidth;
                    canvas.height = video.videoHeight;
                    canvasContext = canvas.getContext('2d', { 
                        willReadFrequently: true,
                        alpha: false 
                    });
                });
                
                responseText.value = "Camera ready. You can start processing.";
            } catch (err) {
                console.error("Error accessing camera:", err);
                responseText.value = `Camera error: ${err.message}`;
                updateModelStatus('error', 'Camera access denied');
                
                // More user-friendly error message for mobile
                const errorMessage = err.name === 'NotAllowedError' 
                    ? 'Camera permission denied. Please allow camera access in your browser settings.'
                    : `Error accessing camera: ${err.name}. Please grant camera permission.`;
                    
                alert(errorMessage);
            }
        }

        // Optimized speech recognition with debouncing
        function initSpeechRecognition() {
            if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
                statusText.textContent = "Speech recognition not supported in this browser";
                return false;
            }

            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            recognition = new SpeechRecognition();
            
            recognition.continuous = true;
            recognition.interimResults = true;
            recognition.lang = 'en-US';
            
            let speechTimeout;
            
            recognition.onresult = (event) => {
                const startTime = performance.now();
                let finalTranscript = '';
                let interimTranscript = '';
                
                for (let i = event.resultIndex; i < event.results.length; i++) {
                    const transcript = event.results[i][0].transcript;
                    if (event.results[i].isFinal) {
                        finalTranscript += transcript;
                    } else {
                        interimTranscript += transcript;
                    }
                }
                
                if (finalTranscript && finalTranscript !== lastProcessedSpeech) {
                    instructionText.value = finalTranscript;
                    lastProcessedSpeech = finalTranscript;
                    statusText.textContent = `Heard: "${finalTranscript}"`;
                    
                    // Debounce processing
                    clearTimeout(speechTimeout);
                    speechTimeout = setTimeout(() => {
                        queueProcessing('speech', finalTranscript);
                    }, 500);
                } else if (interimTranscript) {
                    instructionText.value = interimTranscript;
                    statusText.textContent = "Listening...";
                }
                
                speechProcessingTime = performance.now() - startTime;
                speechTimeSpan.textContent = speechProcessingTime.toFixed(1);
            };
            
            recognition.onerror = (event) => {
                console.error('Speech recognition error:', event.error);
                if (event.error === 'no-speech') {
                    statusText.textContent = "No speech detected";
                } else if (event.error === 'audio-capture') {
                    statusText.textContent = "Microphone access denied";
                } else {
                    statusText.textContent = `Speech recognition error: ${event.error}`;
                }
            };
            
            recognition.onend = () => {
                if (isAssistantActive) {
                    try {
                        recognition.start();
                    } catch (error) {
                        console.error('Error restarting speech recognition:', error);
                    }
                }
            };
            
            return true;
        }

        // Processing queue to prevent concurrent processing
        function queueProcessing(type, data) {
            processingQueue.push({ type, data, timestamp: Date.now() });
            processQueue();
        }

        async function processQueue() {
            if (isProcessing || processingQueue.length === 0) return;
            
            isProcessing = true;
            const item = processingQueue.shift();
            
            try {
                if (item.type === 'speech') {
                    await processCompleteInteraction(item.data);
                } else if (item.type === 'vision') {
                    await processImage();
                }
            } catch (error) {
                console.error('Error processing queue item:', error);
            } finally {
                isProcessing = false;
                // Process next item
                if (processingQueue.length > 0) {
                    setTimeout(processQueue, 100); // Small delay to prevent blocking
                }
            }
        }

        // Optimized image change detection
        function detectImageChange() {
            if (!canvasContext) return true;
            
            const imageData = canvasContext.getImageData(0, 0, canvas.width, canvas.height);
            
            if (!previousImageData) {
                previousImageData = imageData.data.slice();
                return true;
            }
            
            let diffCount = 0;
            const totalPixels = imageData.data.length / 4;
            const sampleRate = 10; // Sample every 10th pixel for performance
            
            for (let i = 0; i < imageData.data.length; i += 4 * sampleRate) {
                const r1 = previousImageData[i];
                const g1 = previousImageData[i + 1];
                const b1 = previousImageData[i + 2];
                const r2 = imageData.data[i];
                const g2 = imageData.data[i + 1];
                const b2 = imageData.data[i + 2];
                
                const diff = Math.abs(r1 - r2) + Math.abs(g1 - g2) + Math.abs(b1 - b2);
                if (diff > 30) { // Threshold for pixel change
                    diffCount++;
                }
            }
            
            const changePercentage = (diffCount * sampleRate) / totalPixels;
            const hasChanged = changePercentage > CHANGE_THRESHOLD;
            
            if (hasChanged) {
                previousImageData = imageData.data.slice();
            }
            
            return hasChanged;
        }

        // Optimized complete interaction processing with caching
        async function processCompleteInteraction(instruction) {
            if (!isModelReady) return;

            const cacheKey = `${instruction}_${lastProcessedVision}`;
            if (responseCache.has(cacheKey)) {
                const cachedResponse = responseCache.get(cacheKey);
                responseText.value = cachedResponse;
                statusText.textContent = "Using cached response";
                await speakResponse(cachedResponse);
                return;
            }

            const imageDataUrl = captureImage();
            if (!imageDataUrl) {
                responseText.value = "Failed to capture image for processing.";
                return;
            }

            try {
                const startTime = performance.now();
                
                // Only process vision if image has changed significantly
                let visionText = lastProcessedVision;
                if (detectImageChange()) {
                    const visionResult = await visionProcessor(imageDataUrl);
                    visionText = visionResult[0].generated_text;
                    visionCaption.textContent = visionText;
                    lastProcessedVision = visionText;
                }

                visionProcessingTime = performance.now() - startTime;
                visionTimeSpan.textContent = visionProcessingTime.toFixed(1);

                // Generate intelligent response
                let response = generateResponse(instruction, visionText);
                
                // Cache the response
                if (responseCache.size >= CACHE_MAX_SIZE) {
                    const firstKey = responseCache.keys().next().value;
                    responseCache.delete(firstKey);
                }
                responseCache.set(cacheKey, response);
                
                responseText.value = response;
                statusText.textContent = "Speaking response...";
                
                await speakResponse(response);
                
            } catch (error) {
                console.error('Error processing interaction:', error);
                responseText.value = `Error: ${error.message}`;
                statusText.textContent = "Processing failed";
            }
        }

        // Optimized response generation
        function generateResponse(instruction, visionText) {
            const question = instruction.toLowerCase();
            
            if (question.includes('what') && question.includes('see')) {
                return `I can see ${visionText}.`;
            } else if (question.includes('describe') || question.includes('tell me about')) {
                return `Based on what I can see, ${visionText}.`;
            } else if (question.includes('how many') || question.includes('count')) {
                return `Looking at the image, I can see ${visionText}. Let me count the objects for you.`;
            } else if (question.includes('color') || question.includes('colour')) {
                return `In the image, I can see ${visionText}. The colors I notice are described in the vision analysis.`;
            } else {
                return `You asked: "${instruction}". Based on what I can see (${visionText}), I can help answer your question about the visual content.`;
            }
        }

        // Optimized speech synthesis with queue
        let speechQueue = [];
        let isSpeaking = false;

        async function speakResponse(text) {
            if (!text) return;

            speechQueue.push(text);
            processSpeechQueue();
        }

        function processSpeechQueue() {
            if (isSpeaking || speechQueue.length === 0) return;
            
            isSpeaking = true;
            const text = speechQueue.shift();
            
            try {
                statusText.textContent = "Speaking...";
                
                const utterance = new SpeechSynthesisUtterance(text);
                utterance.rate = 0.9;
                utterance.pitch = 1.0;
                utterance.volume = 1.0;
                
                utterance.onend = () => {
                    isSpeaking = false;
                    statusText.textContent = "Ready for next question";
                    processSpeechQueue(); // Process next in queue
                };
                
                utterance.onerror = (error) => {
                    console.error('Speech synthesis error:', error);
                    isSpeaking = false;
                    statusText.textContent = "Speech failed";
                    processSpeechQueue(); // Continue with next
                };
                
                window.speechSynthesis.speak(utterance);
                
            } catch (error) {
                console.error('Error with speech synthesis:', error);
                isSpeaking = false;
                statusText.textContent = "Speech synthesis failed";
                processSpeechQueue(); // Continue with next
            }
        }

        // Optimized image capture
        function captureImage() {
            if (!stream || !video.videoWidth || !canvasContext) {
                console.warn("Video stream not ready for capture.");
                return null;
            }
            
            canvasContext.drawImage(video, 0, 0, canvas.width, canvas.height);
            return canvas.toDataURL('image/jpeg', 0.7); // Reduced quality for performance
        }

        // Optimized image processing with adaptive intervals
        async function processImage() {
            if (!isAssistantActive || !isModelReady) return;
            
            // Skip processing if already processing
            if (isProcessing) return;
            
            queueProcessing('vision', null);
        }

        // Performance monitoring
        function updatePerformanceMetrics() {
            const now = performance.now();
            frameCount++;
            
            if (now - lastFrameTime >= 1000) {
                const fps = Math.round(frameCount * 1000 / (now - lastFrameTime));
                fpsSpan.textContent = fps;
                
                frameCount = 0;
                lastFrameTime = now;
            }
        }
        
        // Mobile-specific optimizations
        function optimizeForMobile() {
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            
            if (isMobile) {
                // Reduce processing frequency on mobile for better performance
                const baseInterval = 4000; // 4 seconds on mobile instead of 3
                
                // Adjust change threshold for mobile
                CHANGE_THRESHOLD = 0.15; // 15% change threshold on mobile
                
                // Reduce cache size on mobile to save memory
                CACHE_MAX_SIZE = 30;
                
                // Add mobile-specific event listeners
                document.addEventListener('touchstart', () => {
                    // Prevent double-tap zoom on buttons
                }, { passive: true });
                
                // Handle orientation changes
                window.addEventListener('orientationchange', () => {
                    setTimeout(() => {
                        // Recalculate canvas size after orientation change
                        if (video.videoWidth && video.videoHeight) {
                            canvas.width = video.videoWidth;
                            canvas.height = video.videoHeight;
                        }
                    }, 100);
                });
            }
        }

        // Optimized start assistant
        async function startAssistant() {
            if (!stream) {
                responseText.value = "Camera not available.";
                return;
            }

            if (!recognition) {
                if (!initSpeechRecognition()) {
                    return;
                }
            }

            isAssistantActive = true;
            startButton.textContent = "⏹️ Stop AI Assistant";
            startButton.className = 'btn btn-danger pulse-animation';
            statusText.textContent = "AI Assistant active - speak your questions";

            // Start with immediate processing
            processImage();
            
            // Use adaptive intervals based on device type
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            const baseInterval = isMobile ? 4000 : 3000; // 4 seconds on mobile, 3 on desktop
            intervalId = setInterval(() => {
                processImage();
                updatePerformanceMetrics();
            }, baseInterval);

            try {
                recognition.start();
            } catch (error) {
                console.error('Error starting speech recognition:', error);
                statusText.textContent = "Failed to start speech recognition";
            }
        }

        // Optimized stop assistant
        function stopAssistant() {
            isAssistantActive = false;
            startButton.textContent = "🚀 Start AI Assistant";
            startButton.className = 'btn btn-primary';
            statusText.textContent = "AI Assistant stopped";

            if (intervalId) {
                clearInterval(intervalId);
                intervalId = null;
            }

            if (recognition) {
                try {
                    recognition.stop();
                } catch (error) {
                    console.error('Error stopping speech recognition:', error);
                }
            }

            // Clear queues
            processingQueue.length = 0;
            speechQueue.length = 0;
            isProcessing = false;
            isSpeaking = false;
            
            window.speechSynthesis.cancel();
        }

        // Text input event listener for manual instructions
        instructionText.addEventListener('input', (e) => {
            if (e.target.value.trim() && e.target.value !== lastProcessedSpeech) {
                lastProcessedSpeech = e.target.value;
            }
        });

        // Enter key to process instruction
        instructionText.addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                const instruction = instructionText.value.trim();
                if (instruction) {
                    processCompleteInteraction(instruction);
                }
            }
        });



        // Button event listeners
        startButton.addEventListener('click', () => {
            if (isAssistantActive) {
                stopAssistant();
            } else {
                startAssistant();
            }
        });

        // Error handling for model loading
        window.addEventListener('error', (event) => {
            console.error('Global error:', event.error);
            if (event.error && event.error.message.includes('transformers')) {
                loadingStatus.textContent = 'Error loading AI models. Please check your internet connection.';
                loadingStatus.classList.add('error');
                updateModelStatus('error', 'Failed to load AI models');
            }
        });

        // Network status monitoring
        window.addEventListener('online', () => {
            if (!isModelReady) {
                loadingStatus.textContent = 'Reconnecting to AI models...';
                initModels();
            }
        });

        window.addEventListener('offline', () => {
            if (isAssistantActive) {
                statusText.textContent = 'Network disconnected. AI features may be limited.';
            }
        });

        // Performance optimization: Throttle scroll and resize events
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                // Recalculate canvas size if needed
                if (video.videoWidth && video.videoHeight) {
                    canvas.width = video.videoWidth;
                    canvas.height = video.videoHeight;
                }
            }, 250);
        });

        // Accessibility improvements
        document.addEventListener('keydown', (e) => {
            // Escape key to stop assistant
            if (e.key === 'Escape' && isAssistantActive) {
                stopAssistant();
            }
            
            // Space bar to toggle assistant (when focused on start button)
            if (e.key === ' ' && document.activeElement === startButton) {
                e.preventDefault();
                startButton.click();
            }
        });

        // Memory management
        function cleanupMemory() {
            // Clear caches periodically
            if (responseCache.size > CACHE_MAX_SIZE * 0.8) {
                const keysToDelete = Array.from(responseCache.keys()).slice(0, 10);
                keysToDelete.forEach(key => responseCache.delete(key));
            }
            
            // Clear old processing queue items
            const now = Date.now();
            processingQueue = processingQueue.filter(item => now - item.timestamp < 30000); // Keep only items from last 30 seconds
        }

        // Run cleanup every 30 seconds
        setInterval(cleanupMemory, 30000);

        // Optimized cleanup
        window.addEventListener('beforeunload', () => {
            if (stream) {
                stream.getTracks().forEach(track => track.stop());
            }
            if (recognition && isAssistantActive) {
                recognition.stop();
            }
            if (intervalId) {
                clearInterval(intervalId);
            }
            if (processingWorker) {
                processingWorker.terminate();
            }
            window.speechSynthesis.cancel();
        });

        // Handle page visibility for performance
        document.addEventListener('visibilitychange', () => {
            if (document.hidden && isAssistantActive) {
                // Pause processing when page is hidden
                if (intervalId) {
                    clearInterval(intervalId);
                }
            } else if (!document.hidden && isAssistantActive) {
                // Resume processing when page becomes visible
                intervalId = setInterval(() => {
                    processImage();
                    updatePerformanceMetrics();
                }, 3000);
            }
        });

        // Initialize everything when DOM is ready
        document.addEventListener('DOMContentLoaded', () => {
            // Set initial instruction
            instructionText.value = "What do you see?";
            
            // Apply mobile optimizations
            optimizeForMobile();
            
            // Start model initialization
            initModels();
        });

    </script>
</body>
</html>